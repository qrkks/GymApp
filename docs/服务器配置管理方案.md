# 服务器配置管理方案

## 🎯 问题分析

**构建阶段**（GitHub Actions）：
- ✅ 只需要 Dockerfile 和源代码
- ❌ **不需要** compose 文件（只构建镜像）
- ❌ **不需要** .env 文件（构建时不需要运行时环境变量）

**部署阶段**（服务器）：
- ✅ 需要 compose 文件（启动容器）
- ✅ 需要 .env 文件（运行时环境变量）

## 📋 方案对比

### 方案 1：Compose 通过 Git 管理，.env 在服务器上（推荐）

**工作流程**：
```
GitHub Actions:
  1. 构建 Docker 镜像 ✅
  2. 打包 compose 文件 ✅
  3. 传输到服务器 ✅
  4. 在服务器上创建/更新 .env（首次或更新时）✅
  5. 使用服务器上的 compose + .env 启动容器 ✅
```

**优点**：
- ✅ Compose 文件版本控制，自动更新
- ✅ .env 文件在服务器上，安全且持久
- ✅ 配置变更通过 Git 管理，可追溯

**服务器目录结构**：
```
/home/{USER}/gymapp/
├── frontend/
│   └── deploy/
│       ├── docker-compose.yml      # 从 Git 更新
│       ├── .env                    # 服务器本地，不覆盖
│       └── deploy.sh
```

**GitHub Actions 改进**：
```yaml
- name: Remote load and deploy on server
  run: |
    sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh ... << 'EOF'
      # 加载镜像
      docker load < ~/gymapp-image.tar
      
      # 解压部署文件（包含 compose）
      tar -xzf ~/deploy-files.tar -C "$DEPLOY_DIR/frontend"
      
      # 创建/更新 .env（如果不存在或需要更新）
      cd "$DEPLOY_DIR/frontend/deploy"
      if [ ! -f .env ]; then
        # 首次部署，创建 .env
        cat > .env << 'ENVEOF'
        AUTH_SECRET=${{ secrets.AUTH_SECRET }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
        DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
        NODE_ENV=production
        ENVEOF
        chmod 600 .env
      else
        # 已存在，只更新需要更新的变量（可选）
        # 或者保持不变，手动管理
      fi
      
      # 使用服务器上的 compose + .env 启动
      docker compose --env-file .env up -d
    EOF
```

---

### 方案 2：Compose 和 .env 都在服务器上（完全本地管理）

**工作流程**：
```
GitHub Actions:
  1. 构建 Docker 镜像 ✅
  2. 只传输镜像到服务器 ✅
  3. 在服务器上使用本地 compose + .env 启动 ✅
```

**优点**：
- ✅ 完全控制服务器配置
- ✅ 不依赖 Git 中的 compose 文件
- ✅ 可以手动调整服务器配置

**缺点**：
- ❌ Compose 文件变更需要手动同步
- ❌ 配置变更不可追溯（除非服务器上也有 Git）

**服务器目录结构**：
```
/home/{USER}/gymapp/
├── frontend/
│   └── deploy/
│       ├── docker-compose.yml      # 服务器本地管理
│       ├── .env                    # 服务器本地管理
│       └── deploy.sh
```

**首次设置**（手动）：
```bash
# 在服务器上
cd /home/{USER}/gymapp/frontend/deploy

# 1. 创建 compose 文件（从 Git 复制或手动创建）
# 2. 创建 .env 文件
cat > .env << EOF
AUTH_SECRET=your-secret
POSTGRES_PASSWORD=your-password
NEXTAUTH_URL=https://yourdomain.com
DOMAIN_NAME=yourdomain.com
NODE_ENV=production
EOF
chmod 600 .env
```

**GitHub Actions 简化**：
```yaml
- name: Transfer image to server
  run: |
    sshpass -p "${{ secrets.SERVER_PASSWORD }}" scp \
      gymapp-image.tar \
      ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:~/

- name: Deploy on server
  run: |
    sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh ... << 'EOF'
      # 加载镜像
      docker load < ~/gymapp-image.tar
      rm ~/gymapp-image.tar
      
      # 使用服务器上的 compose + .env
      cd /home/{USER}/gymapp/frontend/deploy
      docker compose --env-file .env up -d
    EOF
```

---

### 方案 3：混合方案 - Compose 通过 Git，.env 完全手动

**工作流程**：
```
GitHub Actions:
  1. 构建 Docker 镜像 ✅
  2. 打包 compose 文件 ✅
  3. 传输到服务器 ✅
  4. 使用服务器上的 .env（不自动创建）✅
```

**优点**：
- ✅ Compose 自动更新
- ✅ .env 完全手动控制，更安全
- ✅ 首次部署需要手动设置 .env

**服务器目录结构**：
```
/home/{USER}/gymapp/
├── frontend/
│   └── deploy/
│       ├── docker-compose.yml      # 从 Git 更新
│       ├── .env                    # 手动创建和管理
│       └── deploy.sh
```

**GitHub Actions**：
```yaml
- name: Deploy on server
  run: |
    sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh ... << 'EOF'
      # 加载镜像
      docker load < ~/gymapp-image.tar
      
      # 解压 compose 文件
      tar -xzf ~/deploy-files.tar -C "$DEPLOY_DIR/frontend"
      
      # 检查 .env 是否存在
      cd "$DEPLOY_DIR/frontend/deploy"
      if [ ! -f .env ]; then
        echo "❌ .env 文件不存在，请手动创建"
        echo "参考 .env.example 创建 .env 文件"
        exit 1
      fi
      
      # 使用服务器上的 compose + .env
      docker compose --env-file .env up -d
    EOF
```

---

## 🎯 推荐方案：方案 1（Compose 通过 Git，.env 在服务器）

### 实施步骤

#### 1. 创建 `.env.example` 模板（提交到 Git）

```bash
# frontend/deploy/.env.example
AUTH_SECRET=your-auth-secret-here
POSTGRES_PASSWORD=your-postgres-password-here
NEXTAUTH_URL=https://yourdomain.com
DOMAIN_NAME=yourdomain.com
NODE_ENV=production
```

#### 2. 更新 `.gitignore`

```gitignore
# 环境变量文件
frontend/deploy/.env
*.env
!.env.example
```

#### 3. 修改 GitHub Actions

```yaml
- name: Remote load and deploy on server
  run: |
    sshpass -p "${{ secrets.SERVER_PASSWORD }}" ssh ... << 'EOF'
      set -e
      
      # 加载镜像
      docker load < ~/gymapp-image.tar
      rm -f ~/gymapp-image.tar
      
      DEPLOY_DIR="/home/${{ secrets.SERVER_USER }}/gymapp"
      mkdir -p "$DEPLOY_DIR/frontend"
      
      # 解压部署文件（包含 compose）
      tar -xzf ~/deploy-files.tar -C "$DEPLOY_DIR/frontend"
      rm -f ~/deploy-files.tar
      
      cd "$DEPLOY_DIR/frontend/deploy"
      
      # 创建或更新 .env 文件
      if [ ! -f .env ]; then
        echo "📝 首次部署，创建 .env 文件..."
        cat > .env << 'ENVEOF'
AUTH_SECRET=${{ secrets.AUTH_SECRET }}
POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
NODE_ENV=production
ENVEOF
        chmod 600 .env
        echo "✅ .env 文件已创建"
      else
        echo "✅ .env 文件已存在，保持不变"
        echo "💡 如需更新环境变量，请手动编辑服务器上的 .env 文件"
      fi
      
      # 使用 compose + .env 启动容器
      echo "🐳 启动容器..."
      docker compose --env-file .env up -d
      
      echo "✅ 部署完成"
    EOF
```

#### 4. 更新 `docker-compose.yml` 使用 `env_file`

```yaml
services:
  gymapp:
    env_file:
      - .env  # 从 .env 文件加载
    environment:
      - AUTH_SECRET=${AUTH_SECRET}
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/gymapp
      # ... 其他变量
```

#### 5. 更新 `deploy.sh` 脚本

```bash
#!/bin/bash
set -e

COMPOSE_FILE="docker-compose.yml"
ENV_FILE=".env"
PROJECT_NAME="gymapp"

# 检查 .env 文件
if [ ! -f "$ENV_FILE" ]; then
  echo "❌ 错误: $ENV_FILE 文件不存在"
  if [ -f ".env.example" ]; then
    echo "💡 请参考 .env.example 创建 $ENV_FILE 文件"
  fi
  exit 1
fi

# 使用 .env 文件执行
docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" -p "$PROJECT_NAME" "$@"
```

## 📊 方案对比总结

| 特性 | 方案 1（推荐） | 方案 2 | 方案 3 |
|------|---------------|--------|--------|
| Compose 版本控制 | ✅ 自动 | ❌ 手动 | ✅ 自动 |
| .env 安全性 | ✅ 服务器本地 | ✅ 服务器本地 | ✅ 服务器本地 |
| 配置更新 | ✅ 自动 | ❌ 手动 | ✅ Compose 自动 |
| 首次部署 | ✅ 自动创建 .env | ❌ 需手动 | ❌ 需手动 |
| 可维护性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |

## 🔒 安全注意事项

1. **.env 文件权限**：
   ```bash
   chmod 600 .env  # 只有所有者可读写
   ```

2. **备份策略**：
   ```bash
   # 备份 .env（加密存储）
   tar -czf env-backup-$(date +%Y%m%d).tar.gz .env
   ```

3. **密钥轮换**：
   - 定期更新 AUTH_SECRET
   - 更新后重启容器

## 🎯 最终建议

**推荐使用方案 1**，因为：
1. ✅ Compose 文件通过 Git 管理，配置变更可追溯
2. ✅ .env 文件在服务器上，安全且持久
3. ✅ 首次部署自动创建 .env，后续可手动调整
4. ✅ 平衡了自动化与灵活性

