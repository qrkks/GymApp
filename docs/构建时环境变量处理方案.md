# 构建时环境变量处理方案

## 🎯 问题

在 GitHub Actions 上构建 Docker 镜像时，没有环境变量会不会报错？

## 📊 当前代码分析

### 1. Next.js 构建时的环境变量需求

**检查结果**：

1. **AUTH_SECRET** - `frontend/lib/auth-config.ts`
   ```typescript
   // 构建时只警告，不报错
   if (!secret) {
     console.warn('AUTH_SECRET is not set. Ensure AUTH_SECRET is provided at runtime...');
   }
   ```
   - ✅ **构建时不需要**，只会在运行时使用

2. **NEXT_PUBLIC_* 变量**
   - ❌ **没有使用**（只有注释掉的代码）
   - ✅ **构建时不需要**

3. **DATABASE_URL / POSTGRES_PASSWORD**
   - ✅ **构建时不需要**，只在运行时连接数据库

4. **NEXTAUTH_URL / DOMAIN_NAME**
   - ✅ **构建时不需要**，只在运行时使用

### 2. Dockerfile 构建过程

```dockerfile
# 构建阶段
RUN pnpm run build  # 执行 next build
```

**Next.js 构建特点**：
- `next build` 是静态构建，不连接数据库
- 不执行 API 路由
- 不执行 `getServerSideProps`（只在运行时执行）
- 只打包代码和静态资源

**结论**：理论上不需要环境变量

---

## ⚠️ 可能的问题场景

### 场景 1：代码在构建时执行了运行时逻辑

**问题代码示例**：
```typescript
// ❌ 错误：在模块顶层执行
const db = getDatabase(); // 构建时就会执行

// ✅ 正确：在函数内执行
function getData() {
  const db = getDatabase(); // 只在运行时执行
}
```

**检查方法**：
```bash
# 在本地测试构建（不设置环境变量）
unset AUTH_SECRET DATABASE_URL
cd frontend
pnpm run build
```

### 场景 2：Next.js 配置问题

**可能的问题**：
- `next.config.mjs` 中使用了环境变量
- 某些插件在构建时需要环境变量

**当前检查**：
```javascript
// next.config.mjs - 没有使用环境变量
const nextConfig = {};
```

### 场景 3：TypeScript/ESLint 检查

**可能的问题**：
- TypeScript 类型检查时访问了环境变量
- ESLint 规则检查

---

## 🔧 解决方案

### 方案 1：构建时提供占位符环境变量（推荐）

**实现方式**：
```yaml
# .github/workflows/deploy.yml
- name: Build Docker image
  uses: docker/build-push-action@v5
  with:
    context: ./frontend
    load: true
    tags: gymapp-frontend:latest
    build-args: |
      AUTH_SECRET=dummy-build-secret
      DATABASE_URL=postgresql://dummy:dummy@dummy:5432/dummy
      NEXTAUTH_URL=https://dummy.com
    cache-from: type=gha
    cache-to: type=gha,mode=max
```

**优点**：
- ✅ 满足构建时的环境变量检查
- ✅ 使用占位符，不泄露真实值
- ✅ 简单直接

**缺点**：
- ⚠️ 需要维护构建参数列表

---

### 方案 2：修改 Dockerfile 使用构建参数

**实现方式**：
```dockerfile
# Dockerfile
FROM node:22-bookworm-slim AS builder

# 构建参数（可选，有默认值）
ARG AUTH_SECRET=dummy-build-secret
ARG DATABASE_URL=postgresql://dummy:dummy@dummy:5432/dummy
ARG NEXTAUTH_URL=https://dummy.com

# 设置为环境变量（构建时使用）
ENV AUTH_SECRET=$AUTH_SECRET
ENV DATABASE_URL=$DATABASE_URL
ENV NEXTAUTH_URL=$NEXTAUTH_URL

# ... 其他构建步骤
RUN pnpm run build
```

**GitHub Actions**：
```yaml
- name: Build Docker image
  uses: docker/build-push-action@v5
  with:
    context: ./frontend
    build-args: |
      AUTH_SECRET=dummy-build-secret
      DATABASE_URL=postgresql://dummy:dummy@dummy:5432/dummy
      NEXTAUTH_URL=https://dummy.com
```

**优点**：
- ✅ 明确指定构建时需要的变量
- ✅ 有默认值，不会报错
- ✅ 符合 Docker 最佳实践

**缺点**：
- ⚠️ 需要修改 Dockerfile

---

### 方案 3：确保代码不在构建时执行运行时逻辑

**检查清单**：
1. ✅ 数据库连接不在模块顶层
2. ✅ API 调用不在构建时执行
3. ✅ 环境变量访问有默认值或可选

**代码示例**：
```typescript
// ✅ 正确：延迟执行
export function getDatabase() {
  // 只在函数调用时执行
  return new Pool({ connectionString: process.env.DATABASE_URL });
}

// ❌ 错误：模块加载时执行
const db = new Pool({ connectionString: process.env.DATABASE_URL });
```

---

### 方案 4：使用 .env.build 文件（不推荐）

**实现方式**：
```bash
# 在 GitHub Actions 中创建
echo "AUTH_SECRET=dummy" > .env.build
echo "DATABASE_URL=dummy" >> .env.build
```

**缺点**：
- ❌ 需要维护额外的文件
- ❌ 可能被提交到 Git

---

## 🎯 推荐方案

### 首选：方案 2（Dockerfile 构建参数）

**理由**：
1. ✅ 明确指定构建时需要的变量
2. ✅ 有默认值，不会报错
3. ✅ 符合 Docker 最佳实践
4. ✅ 不泄露真实密钥

**实施步骤**：

1. **更新 Dockerfile**：
```dockerfile
FROM node:22-bookworm-slim AS builder

WORKDIR /app

# 构建参数（可选，有默认值）
ARG AUTH_SECRET=dummy-build-secret-do-not-use
ARG DATABASE_URL=postgresql://dummy:dummy@dummy:5432/dummy
ARG NEXTAUTH_URL=https://dummy.example.com

# 设置为环境变量（构建时使用）
ENV AUTH_SECRET=$AUTH_SECRET
ENV DATABASE_URL=$DATABASE_URL
ENV NEXTAUTH_URL=$NEXTAUTH_URL

# ... 其他步骤保持不变
RUN apt-get update && apt-get install -y --no-install-recommends \
    python3 curl \
  && rm -rf /var/lib/apt/lists/*

RUN corepack enable pnpm

COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile && \
    echo "✅ PostgreSQL依赖安装完成" && \
    pnpm store prune

COPY . .
RUN mkdir -p public && pnpm run build

# ... 其他步骤
```

2. **更新 GitHub Actions**（可选，因为 Dockerfile 有默认值）：
```yaml
- name: Build Docker image
  uses: docker/build-push-action@v5
  with:
    context: ./frontend
    load: true
    tags: gymapp-frontend:latest
    # 可选：显式指定构建参数（如果 Dockerfile 有默认值，可以不指定）
    build-args: |
      AUTH_SECRET=dummy-build-secret
      DATABASE_URL=postgresql://dummy:dummy@dummy:5432/dummy
      NEXTAUTH_URL=https://dummy.example.com
    cache-from: type=gha
    cache-to: type=gha,mode=max
```

---

## 🧪 测试验证

### 本地测试构建（不设置环境变量）

```bash
# 1. 清除所有环境变量
unset AUTH_SECRET DATABASE_URL NEXTAUTH_URL DOMAIN_NAME

# 2. 测试构建
cd frontend
pnpm run build

# 3. 检查是否有错误
# 如果构建成功，说明不需要环境变量
# 如果构建失败，查看错误信息
```

### 在 GitHub Actions 中测试

```yaml
# 临时添加测试步骤
- name: Test build without env vars
  run: |
    cd frontend
    unset AUTH_SECRET DATABASE_URL NEXTAUTH_URL
    pnpm run build
```

---

## 📝 检查清单

- [ ] 检查代码中是否有模块顶层执行运行时逻辑
- [ ] 检查 `next.config.mjs` 是否使用环境变量
- [ ] 本地测试构建（不设置环境变量）
- [ ] 更新 Dockerfile 添加构建参数（方案 2）
- [ ] 测试 GitHub Actions 构建流程
- [ ] 验证构建产物正常

---

## 💡 如果仍然报错

如果添加构建参数后仍然报错，需要：

1. **查看具体错误信息**
   - 是哪个环境变量缺失？
   - 是在哪个步骤报错？

2. **检查代码**
   - 是否有代码在构建时执行了运行时逻辑？
   - 是否有 TypeScript 类型检查问题？

3. **提供错误日志**
   - 我可以帮你分析具体问题

---

## 🎯 总结

**当前情况**：
- ✅ 代码检查显示构建时理论上不需要环境变量
- ⚠️ 但用户说以前老报错，可能是特定场景

**推荐方案**：
- ✅ **方案 2**：在 Dockerfile 中添加构建参数，提供默认值
- ✅ 这样即使代码在构建时需要环境变量，也不会报错
- ✅ 不泄露真实密钥（使用占位符）

**下一步**：
1. 先测试本地构建（不设置环境变量）
2. 如果没问题，可以保持现状
3. 如果报错，实施方案 2

