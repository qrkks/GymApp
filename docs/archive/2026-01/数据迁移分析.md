# 数据迁移分析：Django → Next.js

## 业务表结构对比

### ✅ 业务表基本一致

| 表名 | Django | Next.js | 差异 |
|------|--------|---------|------|
| `body_parts` | ✅ | ✅ | `user_id` 类型不同（整数 vs 文本） |
| `exercises` | ✅ | ✅ | `user_id` 类型不同（整数 vs 文本） |
| `workouts` | ✅ | ✅ | `user_id` 类型不同，日期格式不同 |
| `workout_sets` | ✅ | ✅ | `user_id` 类型不同（整数 vs 文本） |
| `sets` | ✅ | ✅ | `user_id` 类型不同（整数 vs 文本） |
| `workout_body_parts` | ✅ | ✅ | 完全一致 |

**结论：业务表结构基本一致，主要差异是 `user_id` 类型和日期格式。**

---

## ❌ User 表差异（关键问题）

### Django `auth_user` 表结构

Django 使用内置的 `auth_user` 表，标准字段：
- `id` - INTEGER (主键，自增)
- `username` - VARCHAR(150) (唯一)
- `email` - VARCHAR(254) (可为空)
- `password` - VARCHAR(128) (密码哈希)
- `first_name` - VARCHAR(150)
- `last_name` - VARCHAR(150)
- `is_active` - BOOLEAN
- `is_staff` - BOOLEAN
- `is_superuser` - BOOLEAN
- `date_joined` - DATETIME
- `last_login` - DATETIME (可为空)

### Next.js `users` 表结构

Next.js 使用 NextAuth.js 格式的 `users` 表：
- `id` - TEXT (主键，通常是 UUID)
- `username` - TEXT (唯一，必填)
- `email` - TEXT (唯一，可为空)
- `password` - TEXT (密码哈希，可为空)
- `emailVerified` - INTEGER (布尔值)
- `image` - TEXT (可为空)
- `createdAt` - INTEGER (时间戳)
- `updatedAt` - INTEGER (时间戳，可为空)

---

## 关键差异总结

### 1. User ID 类型
- **Django**: 整数（1, 2, 3...）
- **Next.js**: 文本（UUID 或字符串）

### 2. User 表字段
- **Django**: Django 内置字段（`first_name`, `last_name`, `is_active` 等）
- **Next.js**: NextAuth.js 字段（`emailVerified`, `image`, `createdAt` 等）

### 3. 所有业务表的 `user_id`
- **Django**: 整数（引用 `auth_user.id`）
- **Next.js**: 文本（引用 `users.id`）

### 4. 日期格式
- **Django**: 
  - `date` - DateField (存储为日期)
  - `start_time`/`end_time` - DateTimeField (存储为日期时间)
- **Next.js**:
  - `date` - TEXT (存储为 "YYYY-MM-DD")
  - `start_time`/`end_time` - INTEGER (存储为时间戳)

---

## 数据迁移方案

### 方案 1：ID 映射表（推荐）

**思路：**
1. 创建 ID 映射表：`django_user_id` → `nextjs_user_id`
2. 迁移用户数据，生成新的文本 ID（UUID）
3. 使用映射表转换所有业务表的 `user_id`

**优点：**
- 保持业务数据完整性
- 可以追踪原始用户
- 支持回滚

**步骤：**
```sql
-- 1. 创建映射表
CREATE TABLE user_id_mapping (
  django_user_id INTEGER PRIMARY KEY,
  nextjs_user_id TEXT NOT NULL UNIQUE
);

-- 2. 迁移用户数据并建立映射
-- Django user.id=1 → Next.js user.id='uuid-1'
-- Django user.id=2 → Next.js user.id='uuid-2'

-- 3. 转换所有业务表的 user_id
UPDATE body_parts 
SET user_id = (SELECT nextjs_user_id FROM user_id_mapping WHERE django_user_id = body_parts.user_id);
```

---

### 方案 2：直接转换 ID（简单但不推荐）

**思路：**
- 将 Django 整数 ID 直接转换为文本（"1", "2", "3"...）

**优点：**
- 简单直接
- 不需要映射表

**缺点：**
- ID 格式不符合 NextAuth.js 规范（通常是 UUID）
- 未来可能有问题

**示例：**
```sql
-- 迁移用户
INSERT INTO users (id, username, email, password, ...)
SELECT 
  CAST(id AS TEXT) as id,  -- 整数转文本
  username,
  email,
  password,
  ...
FROM auth_user;

-- 转换业务表
UPDATE body_parts SET user_id = CAST(user_id AS TEXT);
```

---

### 方案 3：使用 UUID（推荐用于新系统）

**思路：**
- 为每个用户生成新的 UUID
- 建立完整的映射关系

**优点：**
- 符合 NextAuth.js 规范
- 更安全（不暴露用户数量）
- 未来兼容性好

**缺点：**
- 需要维护映射表
- 稍微复杂

---

## 推荐方案

### 推荐：方案 1（ID 映射表）+ UUID

**理由：**
1. 保持数据完整性
2. 符合 NextAuth.js 规范
3. 可以追踪原始用户
4. 支持验证和回滚

**迁移步骤：**

1. **创建映射表**
   ```sql
   CREATE TABLE user_id_mapping (
     django_user_id INTEGER PRIMARY KEY,
     nextjs_user_id TEXT NOT NULL UNIQUE,
     username TEXT NOT NULL
   );
   ```

2. **迁移用户数据**
   ```sql
   -- 为每个 Django 用户生成 UUID
   INSERT INTO users (id, username, email, password, emailVerified, createdAt, updatedAt)
   SELECT 
     lower(hex(randomblob(4)) || '-' || hex(randomblob(2)) || '-4' || substr(hex(randomblob(2)), 2) || '-' || substr('89ab', abs(random()) % 4 + 1, 1) || substr(hex(randomblob(2)), 2) || '-' || hex(randomblob(6))) as id,
     username,
     email,
     password,
     CASE WHEN is_active = 1 THEN 1 ELSE 0 END as emailVerified,
     strftime('%s', date_joined) as createdAt,
     strftime('%s', COALESCE(last_login, date_joined)) as updatedAt
   FROM auth_user;
   
   -- 建立映射
   INSERT INTO user_id_mapping (django_user_id, nextjs_user_id, username)
   SELECT au.id, u.id, u.username
   FROM auth_user au
   JOIN users u ON au.username = u.username;
   ```

3. **转换业务表的 user_id**
   ```sql
   UPDATE body_parts 
   SET user_id = (SELECT nextjs_user_id FROM user_id_mapping WHERE django_user_id = CAST(body_parts.user_id AS INTEGER));
   
   UPDATE exercises 
   SET user_id = (SELECT nextjs_user_id FROM user_id_mapping WHERE django_user_id = CAST(exercises.user_id AS INTEGER));
   
   -- ... 其他表类似
   ```

4. **转换日期格式**
   ```sql
   -- workouts.date: DateField → text
   UPDATE workouts SET date = date(date);
   
   -- workouts.start_time: DateTimeField → timestamp
   UPDATE workouts SET start_time = strftime('%s', start_time);
   
   -- workouts.end_time: DateTimeField → timestamp (可为空)
   UPDATE workouts SET end_time = CASE 
     WHEN end_time IS NULL THEN NULL 
     ELSE strftime('%s', end_time) 
   END;
   ```

5. **验证数据**
   - 检查用户数量
   - 检查外键关系
   - 检查日期格式

---

## 注意事项

1. **密码哈希格式**
   - Django 使用 `pbkdf2_sha256`
   - NextAuth.js 也支持多种格式
   - 需要确认兼容性

2. **邮箱验证状态**
   - Django 没有 `emailVerified` 字段
   - 可以用 `is_active` 映射，或设为默认值

3. **用户图片**
   - Django 没有 `image` 字段
   - 可以设为 NULL

4. **时间戳**
   - Django `date_joined` 是 DATETIME
   - Next.js `createdAt` 是 INTEGER（时间戳）
   - 需要转换

---

## 总结

**你的理解完全正确：**
- ✅ 业务表结构基本一致
- ✅ 主要问题是 user 表不一致
- ✅ 需要处理 user_id 类型转换
- ✅ 需要处理日期格式转换

**关键任务：**
1. 迁移 `auth_user` → `users`（ID 转换）
2. 转换所有业务表的 `user_id`（整数 → 文本）
3. 转换日期格式（DateField → text，DateTimeField → timestamp）

