# 错误处理层次说明

## 📊 错误处理的三个层次

### 1. 领域层（Use-Case）✅ 已统一

**职责：** 业务逻辑层的错误处理

```typescript
// domain/shared/error-types.ts
export type Result<T> =
  | { success: true; data: T }
  | { success: false; error: UseCaseError };

// 使用示例
const result = await createUser(data);
if (!result.success) {
  // 错误信息已经在 result.error 中
  return result; // 返回给调用者
}
```

**特点：**
- ✅ 统一的错误类型（`Result<T>`）
- ✅ 统一的错误代码（`ErrorCode`）
- ✅ 业务逻辑错误已封装

---

### 2. API 层（Routes）✅ 已统一

**职责：** HTTP 协议适配器，处理 HTTP 相关事务并调用领域层

**API 层做了 6 件事：**

1. **认证检查** - 使用 `requireAuth()` 检查用户是否登录
2. **请求验证** - 使用 Zod 验证 HTTP 请求数据格式
3. **调用 Use-Case** - 调用领域层的 use-case 函数
4. **错误转换** - 使用 `toHttpResponse` 将 `Result<T>` 转换为 HTTP 响应
5. **HTTP 响应** - 返回 JSON 格式的 HTTP 响应
6. **异常处理** - 处理 Zod 验证错误、认证错误等 HTTP 层面异常

```typescript
// app/api/workout/route.ts
// 1. 认证检查
const user = await requireAuth();

// 2. 请求验证
const data = workoutSchema.parse(body);

// 3. 调用 Use-Case
const result = await createWorkout(user.id, data);

// 4. 错误转换
const response = toHttpResponse(result);
// { status: 200, body: data } 或 { status: 400, body: { error: "..." } }

// 5. HTTP 响应
return NextResponse.json(response.body, { status: response.status });
```

**特点：**
- ✅ 使用 `toHttpResponse` 统一转换领域错误
- ✅ 错误代码映射到 HTTP 状态码（`getStatusCode`）
- ✅ 错误信息在响应体中：`{ error: "错误信息" }`
- ✅ 处理 HTTP 特定问题（认证、请求验证、异常）

---

### 3. 前端层（UI）⚠️ 需要统一

**职责：** 处理多种错误来源并统一显示

#### 为什么前端还需要统一错误处理？

虽然领域层和 API 层已经统一了错误处理，但前端需要处理**多种错误来源**：

##### 错误来源 1：API 返回的错误（来自领域层）
```typescript
// API 返回：{ error: "用户名已被使用" }
fetch('/api/user/signup', ...)
  .then(async (res) => {
    const data = await res.json();
    if (!res.ok) {
      // 这是来自领域层的错误
      showToast.error("注册失败", data.error);
    }
  })
```

##### 错误来源 2：网络错误
```typescript
fetch('/api/workout', ...)
  .catch((error) => {
    // 这是网络错误，不是领域层错误
    if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
      showToast.error("网络错误", "请检查网络连接");
    }
  })
```

##### 错误来源 3：客户端验证错误
```typescript
// 这是前端验证，不经过领域层
if (formData.password !== formData.confirmPassword) {
  showToast.error("验证失败", "密码和确认密码不匹配");
  return;
}
```

##### 错误来源 4：其他运行时错误
```typescript
try {
  const data = JSON.parse(response);
} catch (error) {
  // JSON 解析错误
  showToast.error("数据错误", "服务器返回的数据格式不正确");
}
```

---

## 🎯 前端统一错误处理的目的

### 1. 统一显示方式
- **之前：** 有些用 `alert`，有些用 `console.error`，有些用内联错误
- **现在：** 统一使用 Toast 显示

### 2. 处理多种错误来源
- API 错误（来自领域层）
- 网络错误
- 客户端验证错误
- 运行时错误

### 3. 提供一致的用户体验
- 所有错误都有明确的提示
- 所有操作都有成功/失败反馈
- 统一的错误样式和位置

---

## 📋 当前实现

### 领域层 → API 层
```typescript
// Use-Case 返回 Result
const result = await createUser(data);

// API 转换为 HTTP 响应
const response = toHttpResponse(result);
// { status: 400, body: { error: "用户名已被使用" } }
```

### API 层 → 前端
```typescript
// 前端接收 HTTP 响应
const res = await fetch('/api/user/signup', ...);
const data = await res.json();

// 统一处理错误
if (!res.ok) {
  showToast.error("操作失败", data.error); // 显示领域层的错误信息
}
```

---

## 🔄 错误流转路径

```
用户操作
  ↓
前端验证（客户端错误）
  ↓
API 请求
  ↓
API 层（Zod 验证、认证等）
  ↓
Use-Case 层（业务逻辑错误）✅ 已统一
  ↓
toHttpResponse（转换为 HTTP）✅ 已统一
  ↓
前端接收响应
  ↓
统一显示（Toast）⚠️ 需要统一
```

---

## 💡 总结

### 领域层统一错误处理的作用：
- ✅ 统一业务逻辑错误类型
- ✅ 统一错误代码和消息
- ✅ 便于 API 层转换

### 前端统一错误处理的作用：
- ✅ 统一错误显示方式（Toast）
- ✅ 处理多种错误来源（API、网络、客户端、运行时）
- ✅ 提供一致的用户体验

**两者是互补的，不是重复的：**
- **领域层**：统一业务错误的结构和类型
- **前端层**：统一错误的显示和处理方式

---

## 🎯 建议

当前实现已经很好：
1. ✅ 领域层使用 `Result<T>` 统一错误
2. ✅ API 层使用 `toHttpResponse` 统一转换
3. ✅ 前端使用 `showToast` 统一显示

**可以进一步优化：**
- 创建统一的 API 请求封装函数，自动处理错误
- 根据错误代码显示不同的提示（如：网络错误、业务错误、验证错误）

