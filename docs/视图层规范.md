# 视图层规范

本文档定义前端视图层（React/Next.js）的命名和组织规范，基于行业最佳实践。

---

## 1. 文件命名规范

### 1.1 React 组件文件

**规则：使用 PascalCase**

- 组件文件名必须与组件名完全一致
- 使用 `.tsx` 作为文件扩展名（TypeScript）
- 如果项目使用 JavaScript，使用 `.jsx`

**示例：**
- 组件名 `UserProfile` → 文件名 `UserProfile.tsx`
- 组件名 `NavBar` → 文件名 `NavBar.tsx`
- 组件名 `ExerciseGroup` → 文件名 `ExerciseGroup.tsx`

**禁止：**
- 使用小写或 kebab-case（`user-profile.tsx`）
- 使用 camelCase（`userProfile.tsx`）
- 组件名和文件名不一致

### 1.2 Next.js 页面文件

**规则：使用小写**

- 页面文件必须命名为 `page.tsx`（App Router）
- 布局文件必须命名为 `layout.tsx`
- 加载文件必须命名为 `loading.tsx`
- 错误文件必须命名为 `error.tsx`

**说明：** 这是 Next.js 的约定，必须遵守。

### 1.3 路由目录命名

**规则：使用 kebab-case**

- 路由目录使用小写字母和连字符
- 使用单数形式（除非语义上必须使用复数）

**示例：**
- `/user/profile` → `app/user/profile/`
- `/exercise-library` → `app/exercise-library/`
- `/workout/[date]` → `app/workout/[date]/`

**禁止：**
- 使用 PascalCase（`User/Profile/`）
- 使用 camelCase（`userProfile/`）
- 使用下划线（`user_profile/`）

### 1.4 组件目录命名

**规则：优先使用 PascalCase，也可使用 kebab-case**

- 如果目录包含单个主组件，使用 PascalCase（与组件名一致）
- 如果目录包含多个相关组件，可以使用 kebab-case

**说明：** 两种方式都可以，但必须在项目内保持一致。

### 1.5 工具函数和辅助文件

**规则：使用 camelCase**

- 工具函数文件使用 camelCase
- 文件扩展名使用 `.ts`（纯 TypeScript）或 `.tsx`（包含 JSX）

**示例：**
- `formatDate.ts`
- `validateInput.ts`
- `apiHelpers.ts`

---

## 2. 组件命名规范

### 2.1 组件名

**规则：使用 PascalCase**

- 组件名必须以大写字母开头
- 使用描述性的名词或名词短语
- 组件名必须与文件名完全一致

**禁止：**
- 使用小写（`index`, `button`）
- 使用动词（`create`, `update`, `delete`）
- 使用缩写（除非是广泛认知的，如 `API`, `URL`）

### 2.2 组件导出

**规则：使用默认导出**

- 每个组件文件只导出一个主组件
- 使用 `export default function ComponentName()`
- 如果组件需要命名导出（用于测试），可以同时使用命名导出

**禁止：**
- 使用小写函数名然后默认导出（`function index()` → `export default index`）
- 在同一个文件中导出多个组件（除非是相关的小组件）

### 2.3 组件文件组织

**规则：一个文件一个组件**

- 每个组件文件只包含一个主组件
- 相关的辅助组件、类型、工具函数可以放在同一目录下
- 使用 `index.tsx` 作为目录入口时，组件名必须是目录名对应的 PascalCase

**说明：** 如果使用 `ComponentName/index.tsx` 结构，组件名必须是 `ComponentName`，不能是 `index`。

---

## 3. 目录结构规范

### 3.1 Next.js App Router 结构

**规则：按功能组织，使用嵌套路由**

- 页面路由在 `app/` 目录下
- 每个路由段对应一个目录
- 动态路由使用 `[param]` 格式
- 路由组使用 `(group)` 格式

### 3.2 组件组织

**规则：按功能或领域组织**

**方案 1：按功能组织（推荐）**
- 所有组件放在 `components/` 目录
- 使用子目录组织相关组件
- 共享组件放在 `components/` 根目录

**方案 2：按领域组织**
- 组件放在各自领域的目录下
- 共享组件放在 `components/shared/`

**规则：保持一致性**
- 选择一种组织方式，在整个项目中保持一致
- 不要混用多种组织方式

### 3.3 组件目录结构

**规则：扁平化优先，必要时嵌套**

- 优先使用扁平结构
- 只有当组件及其子组件形成明显的层次关系时，才使用嵌套目录
- 嵌套深度不超过 3 层

---

## 4. 类型定义规范

### 4.1 Props 类型

**规则：使用 TypeScript 接口或类型别名**

- Props 类型命名为 `ComponentNameProps`
- 使用 `interface` 定义 Props（推荐）
- 如果 Props 需要扩展，使用 `interface` 而不是 `type`

### 4.2 类型文件

**规则：类型定义位置**

- 简单类型：直接定义在组件文件中
- 复杂类型：定义在组件文件顶部
- 共享类型：放在 `types/` 目录或 `@types/` 目录
- 类型文件命名：使用 kebab-case（`user.types.ts`）

---

## 5. 样式规范

### 5.1 CSS 类名

**规则：使用 Tailwind CSS 或 CSS Modules**

- 优先使用 Tailwind CSS 工具类
- 如果使用 CSS Modules，类名使用 camelCase
- 如果使用普通 CSS，类名使用 kebab-case

### 5.2 样式文件

**规则：样式文件命名**

- CSS Modules：`ComponentName.module.css`
- 普通 CSS：`ComponentName.css` 或全局 `globals.css`
- Tailwind：不需要单独文件，使用配置文件

---

## 6. 导入导出规范

### 6.1 导入顺序

**规则：按类型分组，组内按字母顺序**

1. React 和 Next.js 核心导入
2. 第三方库导入
3. 内部组件导入
4. 工具函数和类型导入
5. 样式导入

### 6.2 导入路径

**规则：使用绝对路径别名**

- 使用路径别名（如 `@/components`, `@/lib`）
- 避免使用相对路径（`../../../components`）
- 路径别名在 `tsconfig.json` 或 `jsconfig.json` 中配置

### 6.3 导出方式

**规则：明确导出**

- 主组件使用默认导出
- 辅助函数、类型、常量使用命名导出
- 避免使用 `export *`（除非是明确的 barrel export）

---

## 7. 代码组织规范

### 7.1 组件结构

**规则：按逻辑顺序组织**

1. 导入语句
2. 类型定义
3. 常量定义
4. 工具函数
5. 主组件
6. 导出语句

### 7.2 Hooks 使用

**规则：遵循 React Hooks 规则**

- Hooks 必须在组件顶层调用
- 自定义 Hooks 以 `use` 开头
- 自定义 Hooks 放在 `hooks/` 目录或组件同目录

### 7.3 状态管理

**规则：选择合适的状态管理方案**

- 本地状态：使用 `useState` 或 `useReducer`
- 共享状态：使用 Context API 或状态管理库
- 服务器状态：使用 SWR、React Query 等

---

## 8. 文件扩展名规范

### 8.1 TypeScript vs JavaScript

**规则：优先使用 TypeScript**

- 新文件使用 `.tsx`（包含 JSX）或 `.ts`（纯 TypeScript）
- 逐步迁移现有 `.jsx` 文件到 `.tsx`
- 配置文件可以使用 `.js`（如果框架要求）

### 8.2 文件类型对应

- React 组件：`.tsx`
- 纯 TypeScript 文件：`.ts`
- 样式文件：`.css`, `.module.css`, `.scss`
- 测试文件：`.test.tsx`, `.spec.tsx`

---

## 9. 命名约定总结

### 9.1 文件命名

| 文件类型 | 命名规则 | 示例 |
|---------|---------|------|
| React 组件 | PascalCase.tsx | `UserProfile.tsx` |
| Next.js 页面 | 小写 page.tsx | `page.tsx` |
| 路由目录 | kebab-case | `user-profile/` |
| 工具函数 | camelCase.ts | `formatDate.ts` |
| 类型文件 | kebab-case.types.ts | `user.types.ts` |
| 测试文件 | ComponentName.test.tsx | `UserProfile.test.tsx` |

### 9.2 目录命名

| 目录类型 | 命名规则 | 示例 |
|---------|---------|------|
| 路由目录 | kebab-case | `exercise-library/` |
| 组件目录 | PascalCase 或 kebab-case | `UserProfile/` 或 `user-profile/` |
| 工具目录 | kebab-case | `utils/`, `helpers/` |
| 类型目录 | kebab-case | `types/`, `@types/` |

### 9.3 标识符命名

| 标识符类型 | 命名规则 | 示例 |
|---------|---------|------|
| 组件名 | PascalCase | `UserProfile` |
| 函数名 | camelCase | `handleSubmit` |
| 变量名 | camelCase | `userName` |
| 常量名 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT` |
| Props 类型 | ComponentNameProps | `UserProfileProps` |
| 自定义 Hook | use + PascalCase | `useUserData` |

---

## 10. 最佳实践

### 10.1 组件设计原则

- **单一职责**：每个组件只做一件事
- **可复用性**：设计可复用的组件
- **可测试性**：组件应该易于测试
- **可维护性**：代码清晰，易于理解

### 10.2 文件组织原则

- **一致性**：在整个项目中保持一致的命名和组织方式
- **可发现性**：文件位置应该容易找到
- **可扩展性**：结构应该支持项目增长
- **清晰性**：目录结构应该反映应用的功能结构

### 10.3 代码质量原则

- **类型安全**：使用 TypeScript 提供类型安全
- **错误处理**：正确处理错误和边界情况
- **性能优化**：注意性能，避免不必要的重渲染
- **可访问性**：遵循可访问性最佳实践

---

## 11. 禁止事项

### 11.1 命名禁止

- ❌ 组件名使用小写（`index`, `button`）
- ❌ 组件名和文件名不一致
- ❌ 使用动词作为组件名（`create`, `update`）
- ❌ 使用缩写（除非是广泛认知的）
- ❌ 文件名和组件名使用不同的命名风格

### 11.2 组织禁止

- ❌ 组件文件放在路由目录中（除非是页面特定组件）
- ❌ 深度嵌套超过 3 层
- ❌ 混用多种组织方式
- ❌ 使用 `index.js` 但组件名不是目录名

### 11.3 代码禁止

- ❌ 在组件文件中直接调用 API（应该使用 Hooks 或服务层）
- ❌ 在组件中直接操作 DOM（除非必要，使用 React 方式）
- ❌ 使用 `any` 类型（除非绝对必要）
- ❌ 忽略 TypeScript 错误

---

## 12. 迁移指南

### 12.1 从混乱到规范

如果现有项目不符合规范，按以下优先级迁移：

1. **高优先级**：修复明显的错误（拼写错误、小写组件名）
2. **中优先级**：统一命名风格（组件名和文件名一致）
3. **低优先级**：重构目录结构（如果需要）

### 12.2 迁移策略

- **渐进式迁移**：不要一次性重构所有文件
- **保持兼容**：迁移时保持功能不变
- **测试覆盖**：迁移后确保测试通过
- **文档更新**：更新相关文档

---

## 13. 工具和检查

### 13.1 代码检查工具

- ESLint：代码质量检查
- Prettier：代码格式化
- TypeScript：类型检查
- 自定义规则：检查命名规范

### 13.2 自动化检查

- 在 CI/CD 中集成代码检查
- 使用 pre-commit hooks 检查代码
- 定期审查代码规范符合度

---

## 14. 总结

视图层规范的核心原则：

1. **一致性**：在整个项目中保持一致的命名和组织方式
2. **清晰性**：命名应该清晰表达意图
3. **可维护性**：结构应该易于理解和维护
4. **可扩展性**：结构应该支持项目增长
5. **最佳实践**：遵循 React 和 Next.js 社区的最佳实践

遵循这些规范可以：
- 提高代码可读性
- 降低维护成本
- 提高开发效率
- 减少错误和 bug
- 改善团队协作

---

**文档版本：** 1.0  
**最后更新：** 2025-01-01

