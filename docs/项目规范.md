# 技术规范标准

本文档定义通用的技术规范标准，适用于任何类型的项目。

## 1. 目录结构规范

### 1.1 领域驱动设计（DDD）结构

```
domain/
├── {domain-name}/              # 领域名称（单数，小写）
│   ├── model/                  # 领域模型（可选）
│   │   └── {entity}.entity.ts
│   ├── service/                # 领域服务（可选）
│   │   └── {domain}.service.ts
│   ├── application/            # 应用服务（必需）
│   │   └── {domain}.use-case.ts
│   └── repository/            # 仓储（可选）
│       ├── commands/           # 写操作
│       │   └── {domain}.repository.ts
│       └── queries/            # 读操作
│           └── {domain}.repository.ts
```

### 1.2 测试文件结构

```
{source-file}.ts
{source-file}.test.ts          # 与源文件同目录

或

__tests__/
  └── {source-file}.test.ts

e2e/                            # E2E 测试独立目录
  └── {feature}.test.ts

tests/                          # 测试辅助
  ├── fixtures/                 # 测试数据
  └── setup/                    # 测试配置
```

## 2. 命名规范

### 2.1 文件命名

- **统一使用 kebab-case**（小写字母 + 连字符）
- ✅ 正确：`user.service.ts`, `auth.repository.ts`
- ❌ 错误：`UserService.ts`, `authRepository.ts`

### 2.2 目录命名

- **统一使用单数**
- ✅ 正确：`service/`, `application/`, `repository/`
- ❌ 错误：`services/`, `applications/`, `repositories/`

### 2.3 函数命名

- **使用 camelCase**
- ✅ 正确：`createSession`, `getUserRoles`, `validateToken`
- ❌ 错误：`CreateSession`, `get_user_roles`

### 2.4 类命名

- **使用 PascalCase**（仅用于实体、值对象）
- ✅ 正确：`User`, `Email`, `Patient`
- ❌ 错误：`user`, `email`

### 2.5 实体文件命名

- **类名**：PascalCase
- **文件名**：kebab-case + `.entity.ts`
- ✅ 正确：类名 `Patient`，文件名 `patient.entity.ts`
- ❌ 错误：类名 `patient`，文件名 `Patient.entity.ts`

### 2.6 测试文件命名

- **单元/集成测试**：`*.test.ts` 或 `*.spec.ts`（统一使用一种）
- **组件测试**：`*.component.test.ts` 或 `*.component.spec.ts`
- **E2E 测试**：`e2e/*.test.ts`

## 3. 分层架构规范

### 3.1 各层职责

#### Model 层（领域模型）

**职责：**
- 封装业务规则
- 保证数据一致性
- 不涉及技术实现

**特点：**
- 纯业务逻辑
- 无外部依赖
- 可被多个应用服务复用

#### Service 层（领域服务）

**职责：**
- 纯业务逻辑
- 不涉及数据库查询
- 不涉及外部系统

**特点：**
- 无状态函数
- 可被多个应用服务复用
- 不调用 Repository

#### Application 层（应用服务）

**职责：**
- 协调 Domain Service、Repository 和 Infrastructure
- 处理完整用例
- 被路由层/控制器调用

**特点：**
- 可以调用 Repository
- 可以调用 Infrastructure
- 可以调用 Domain Service
- 不包含业务规则（业务规则在 Model/Service 层）

#### Repository 层（仓储）

**职责：**
- 封装数据访问逻辑
- 按 CQRS 分离：`commands/`（写）和 `queries/`（读）
- 数据转换（Entity ↔ DTO）

**特点：**
- 被 Application Service 调用
- 不包含业务逻辑
- 只负责数据访问

### 3.2 调用规则

**路由层/控制器：**
- ✅ 只能调用 Application Service
- ✅ 可以使用 Infrastructure（HTTP、加密等）
- ❌ 不允许直接查询数据库
- ❌ 不允许直接调用 Repository
- ❌ 不允许直接调用 Domain Service

**Application Service：**
- ✅ 可以调用 Repository
- ✅ 可以调用 Domain Service
- ✅ 可以调用 Infrastructure
- ❌ 不包含业务规则（业务规则在 Model/Service 层）

**Domain Service：**
- ✅ 纯业务逻辑
- ❌ 不调用 Repository
- ❌ 不涉及外部系统

## 4. 测试规范

### 4.1 测试金字塔

```
        /\
       /E2E\          ← 10% 端到端测试
      /------\
     /Integration\    ← 20% 集成测试
    /------------\
   /   Unit Tests   \ ← 70% 单元测试
  /------------------\
```

### 4.2 测试类型

#### 单元测试（Unit Tests）

**测试目标：**
- 领域模型（Entity、Value Object）
- 领域服务（Domain Service）
- 工具函数

**特点：**
- 完全隔离
- 不依赖外部资源
- 快速执行

#### 集成测试（Integration Tests）

**测试目标：**
- 应用服务（Use Case）
- Repository 与 Use Case 的交互
- API 路由处理

**特点：**
- 使用 Mock 隔离外部依赖
- 测试组件间协作
- 中等执行速度

#### E2E 测试（End-to-End Tests）

**测试目标：**
- 关键用户流程
- 完整功能验证
- 跨页面/模块交互

**特点：**
- 真实环境
- 完整用户流程
- 较慢执行速度

### 4.3 测试组织

**位置：**
- 测试文件与源文件同目录
- 或使用 `__tests__` 目录
- E2E 测试在独立的 `e2e/` 目录

**命名：**
- 与源文件对应：`{source}.test.ts`
- 描述性测试名称：`should {expected behavior} when {condition}`

**结构：**
- 使用 AAA 模式：Arrange（准备）→ Act（执行）→ Assert（断言）
- 每个测试独立运行（测试隔离）

## 5. 代码组织原则

### 5.1 按领域组织

- 每个领域的所有代码都在一个目录下
- 领域之间通过明确的接口交互
- 避免跨领域直接访问

### 5.2 职责分离

- **Model**：业务规则
- **Service**：纯逻辑
- **Application**：协调
- **Repository**：数据访问

### 5.3 渐进式开发

1. 先写 Application Service（包含所有逻辑）
2. 需要时提取 Domain Service（纯业务逻辑被多处使用）
3. 需要时创建 Repository（查询逻辑复杂或需要复用）
4. 需要时引入聚合根（需要保证数据一致性或业务规则复杂）

### 5.4 混合编程模式

- **服务层**：使用函数（函数式编程）
- **聚合根**：使用类（面向对象）
- **简单场景**：不需要聚合根，保持函数式
- **复杂场景**：使用聚合根，保证一致性和业务规则

## 6. 导入路径规范

### 6.1 路径结构

- 使用绝对路径（通过路径别名配置）
- 路径表达类型：`domain/{domain}/application/{domain}.use-case.ts`

### 6.2 导入顺序

1. 框架/库导入
2. 类型导入
3. 领域层导入（Model → Service → Application → Repository）
4. Infrastructure 导入
5. 工具函数导入

## 7. 错误处理规范

### 7.1 错误处理位置

**所有错误在 Application 层（Use Case 层）统一处理**

- ✅ 使用 try-catch 包裹所有逻辑
- ✅ 不向上抛出异常，统一返回 `Result` 类型
- ✅ 将技术异常转换为业务错误
- ✅ 不暴露技术细节给用户

### 7.2 错误类型定义

**错误类型在 `domain/shared/error-types.ts` 统一定义**

- ✅ 所有领域共享相同的错误类型
- ✅ 包含 `ErrorCode`、`UseCaseError`、`Result` 类型
- ✅ 提供创建错误的辅助函数

### 7.3 错误处理模式

**标准模式：整体 try-catch**

- 业务规则错误：在 try 块中直接返回 `{ success: false, error: ... }`
- 成功：返回 `{ success: true, data: ... }`
- 技术错误：在 catch 块中捕获异常，转换为 `{ success: false, error: ... }`

### 7.4 Result 类型

- 使用统一的 Result 类型：`{ success: boolean, data?: T, error?: UseCaseError }`
- 错误包含错误代码（`code`）和错误消息（`message`）
- 路由层根据 `error.code` 转换为相应的 HTTP 状态码

## 8. Repository 组织规范

### 8.1 CQRS 分离

- **commands/**：写操作（insert, update, delete）
- **queries/**：读操作（find, get, list）

### 8.2 函数命名

- **Command**：`insert{Entity}`, `update{Entity}`, `delete{Entity}`
- **Query**：`find{Entity}ById`, `get{Entity}List`, `find{Entity}By{Field}`

## 9. 测试辅助工具

### 9.1 测试 Fixtures

- 位置：`tests/fixtures/`
- 用途：提供可复用的测试数据
- 命名：`{domain}.fixtures.ts`

### 9.2 测试辅助函数

- 位置：`tests/setup/`
- 用途：测试工具函数
- 命名：`test-helpers.ts`

## 10. 通用原则

### 10.1 单一职责

- 每个函数/类只做一件事
- 职责清晰，易于理解和测试

### 10.2 依赖倒置

- 高层模块不依赖低层模块
- 都依赖抽象（接口）

### 10.3 开闭原则

- 对扩展开放
- 对修改关闭

### 10.4 测试驱动

- 编写可测试的代码
- 测试覆盖核心业务逻辑
- 测试即文档

---

**最后更新：** 2024年12月31日
**适用范围：** 通用技术规范，适用于任何类型的项目

